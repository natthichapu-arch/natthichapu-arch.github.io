<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chat Leak Prototype — 20s disappear (No copy)</title>
<style>
  body { font-family: Arial, sans-serif; padding: 20px; background:#f7f7f8; }
  .controls { margin-bottom:12px; }
  #chatBox { 
    border:1px solid #ddd; background:white; height:360px; width:420px; overflow-y:auto; 
    padding:12px; border-radius:8px; box-shadow:0 1px 3px rgba(0,0,0,0.06);
  }
  .message-wrap { margin:8px 0; display:flex; }
  .meta { font-size:12px; color:#666; margin-bottom:6px;}
  .left { justify-content:flex-start; }
  .right { justify-content:flex-end; }
  /* ปิด selection เพื่อยากต่อการไฮไลต์ */
  * { -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; }
  /* ปุ่ม / input */
  #messageInput { width:300px; padding:8px; }
  button { padding:8px 10px; margin-left:6px; cursor:pointer; border-radius:6px; border:1px solid #ccc; background:#fff; }
  /* ข้อความแสดงชั่วคราว (info) */
  #info { margin-top:10px; color:#333; font-size:13px; }
</style>
</head>
<body>

<h2>Chat Prototype — แชทกลุ่มหลุดมือ (ต้นแบบ)</h2>

<div class="controls">
  <label>เลือกผู้ใช้: </label>
  <select id="userSelect">
    <option value="A">User A</option>
    <option value="B">User B</option>
  </select>
  <input id="messageInput" placeholder="พิมพ์ข้อความ..." />
  <button id="sendBtn">ส่ง</button>
  <button id="clearAllBtn" title="ลบข้อความทั้งหมด (เพื่อทดสอบ)">ล้างทั้งหมด</button>
</div>

<div id="chatBox" aria-live="polite"></div>
<div id="info">เมื่อส่ง ข้อความจะหายไปใน <b>20 วินาที</b> และจะแสดงในทุกแท็บ/อุปกรณ์ที่เปิดหน้านี้พร้อมกัน</div>

<script>
(function(){
  const STORAGE_KEY = 'chat_prototype_messages_v1';
  const TIME_TO_LIVE = 20000; // 20 วินาที
  const chatBox = document.getElementById('chatBox');
  const userSelect = document.getElementById('userSelect');
  const input = document.getElementById('messageInput');
  const sendBtn = document.getElementById('sendBtn');
  const clearBtn = document.getElementById('clearAllBtn');

  // ปิด context menu + ป้องกัน copy/cut
  window.addEventListener('contextmenu', e => e.preventDefault());
  window.addEventListener('copy', e => e.preventDefault());
  window.addEventListener('cut', e => e.preventDefault());
  window.addEventListener('keydown', (e) => {
    // ป้องกัน Ctrl/Cmd + C, Ctrl/Cmd + A
    if ((e.ctrlKey || e.metaKey) && ['c','a','x','s'].includes(e.key.toLowerCase())) {
      e.preventDefault();
    }
  });

  // อ่าน messages จาก storage
  function readMessages() {
    try {
      return JSON.parse(localStorage.getItem(STORAGE_KEY)) || [];
    } catch (err) {
      return [];
    }
  }

  function writeMessages(arr) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(arr));
  }

  // สร้าง id แบบง่าย
  function uid() { return 'm_' + Date.now() + '_' + Math.floor(Math.random()*10000); }

  // เพิ่ม message ใหม่ (บันทึกไป storage)
  function addMessage(user, text) {
    const msg = { id: uid(), user, text, ts: Date.now() };
    const arr = readMessages();
    arr.push(msg);
    writeMessages(arr);
    renderMessages(); // update DOM
    scheduleRemoval(msg.id, TIME_TO_LIVE - 100); // remove local view slightly before storage cleanup (smoother)
  }

  // ลบ message โดย id (จาก storage)
  function removeMessageById(id) {
    const arr = readMessages().filter(m => m.id !== id);
    writeMessages(arr);
    renderMessages();
  }

  // ฟังก์ชันลบอัตโนมัติ: หา messages ที่เกิน 20s แล้วลบ
  function cleanupExpired() {
    const now = Date.now();
    const arr = readMessages().filter(m => (now - m.ts) < TIME_TO_LIVE);
    writeMessages(arr);
  }

  // วาดข้อความเป็น canvas เพื่อป้องกันการคัดลอก (best-effort)
  function makeMessageCanvas(text, isRight) {
    // สร้าง canvas ขนาดพอเหมาะ (ประมาณ)
    const padding = 12;
    const fontSize = 14;
    const font = `${fontSize}px Arial, sans-serif`;
    const ctx = document.createElement('canvas').getContext('2d');
    ctx.font = font;
    // วัดความกว้าง (wrap ถ้าจำเป็น)
    const maxWidth = 260;
    const words = text.split(' ');
    const lines = [];
    let line = '';
    for (let w of words) {
      const test = line ? line + ' ' + w : w;
      const width = ctx.measureText(test).width;
      if (width > maxWidth) {
        lines.push(line);
        line = w;
      } else line = test;
    }
    if (line) lines.push(line);
    // ตั้งขนาด canvas
    const width = Math.min(maxWidth + padding*2, Math.max(...lines.map(l => ctx.measureText(l).width)) + padding*2);
    const height = lines.length * (fontSize + 6) + padding*2;
    const canvas = document.createElement('canvas');
    canvas.width = Math.ceil(width);
    canvas.height = Math.ceil(height);
    const c = canvas.getContext('2d');
    // พื้นหลังฟองข้อความ
    c.fillStyle = isRight ? '#f8d7da' : '#d1e7dd';
    roundRect(c, 0, 0, canvas.width, canvas.height, 8, true, false);
    // ข้อความ
    c.font = font;
    c.fillStyle = '#222';
    c.textBaseline = 'top';
    let y = padding;
    lines.forEach(lineText => {
      const x = padding;
      c.fillText(lineText, x, y);
      y += fontSize + 6;
    });
    // ป้องกันการคัดลอกภาพ: disable draggable
    canvas.draggable = false;
    canvas.style.pointerEvents = 'auto';
    canvas.style.borderRadius = '6px';
    return canvas;
  }

  // helper: draw rounded rect
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  // render all messages in DOM
  function renderMessages() {
    cleanupExpired(); // remove expired from storage first
    const arr = readMessages();
    chatBox.innerHTML = '';
    arr.forEach(m => {
      const wrap = document.createElement('div');
      wrap.className = 'message-wrap ' + (m.user === 'A' ? 'left' : 'right');
      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.textContent = (m.user === 'A' ? 'User A' : 'User B') + ' • ' + new Date(m.ts).toLocaleTimeString();
      // canvas as message body
      const canvas = makeMessageCanvas(m.text, m.user === 'B');
      const container = document.createElement('div');
      container.appendChild(meta);
      container.appendChild(canvas);
      // store element reference for possible removal scheduling
      container.dataset.msgId = m.id;
      wrap.appendChild(container);
      chatBox.appendChild(wrap);
      // schedule removal when time done
      const timeLeft = TIME_TO_LIVE - (Date.now() - m.ts);
      if (timeLeft > 0) scheduleRemoval(m.id, timeLeft + 50);
    });
    // scroll to bottom
    chatBox.scrollTop = chatBox.scrollHeight;
  }

  // schedule local removal of message element after delay
  const removalTimers = {};
  function scheduleRemoval(id, delay) {
    if (removalTimers[id]) clearTimeout(removalTimers[id]);
    removalTimers[id] = setTimeout(() => {
      // remove from storage (this will trigger storage event and update all tabs)
      removeMessageById(id);
      delete removalTimers[id];
    }, Math.max(0, delay));
  }

  // event: ส่งข้อความ
  sendBtn.addEventListener('click', () => {
    const text = input.value.trim();
    if (!text) return;
    addMessage(userSelect.value, text);
    input.value = '';
  });

  // Enter key send
  input.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      e.preventDefault();
      sendBtn.click();
    }
  });

  // ล้างทั้งหมด (สำหรับทดสอบ)
  clearBtn.addEventListener('click', () => {
    writeMessages([]);
    renderMessages();
  });

  // sync เมื่อ storage เปลี่ยน (แท็บอื่นส่ง/ลบ)
  window.addEventListener('storage', (e) => {
    if (e.key === STORAGE_KEY) {
      renderMessages();
    }
  });

  // โหลดตอนเริ่ม
  renderMessages();

  // รอบทำความสะอาดเป็นพัก ๆ เผื่อมี message ค้าง
  setInterval(cleanupExpired, 5000);

})();
</script>

</body>
</html>
